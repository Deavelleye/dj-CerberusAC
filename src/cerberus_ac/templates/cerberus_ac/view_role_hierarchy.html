{% load static %}

{# https://jsfiddle.net/6w4op2go/ #}

<style>
  .svg-container {
    display: inline-block;
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* aspect ratio */
    vertical-align: top;
    overflow: hidden;
  }
  .svg-content-responsive {
    display: inline-block;
    position: absolute;
    top: 10px;
    left: 0;
  }

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#licensing {
  fill: green;
}

.link.licensing {
  stroke: green;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<script src="{% static "cerberus_ac/d3/d3.min.js" %}"></script>
<div id="role_hierarchy_chart"></div>
<script>

var links = {{ box.context|safe }};
var nodes = {};

// Compute the distinct nodes from the links.
links.forEach(function(link) {
  link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
  link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
});


var margin = {top: -5, right: -5, bottom: -5, left: -5};
    var width = 500 - margin.left - margin.right,
	height = 400- margin.top - margin.bottom;


var w = 500, h = 300, r = 6;

var color = d3.scale.category20();

var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([900, 500]) // node display area
    .linkDistance(60)
    .linkStrength(2)
    .charge(-300)
    .on("tick", tick)
    .start();

/*
var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([900, 500]) // node display area
    .linkDistance(60)
    .charge(-300)
    .on("tick", tick)
    .start();
*/


var zoom = d3.behavior.zoom().on("zoom", zoomed);

var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted)
    .on("drag", dragged)
    .on("dragend", dragended);

var svg = d3.select("#role_hierarchy_chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.right + ")")
	.call(zoom).on("dblclick.zoom", null);

svg.append("rect")
.attr("class", "overlay")
.attr("width", width)
.attr("height", height);

// http://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js#25978286
// var svg = d3.select("#role_hierarchy_chart")
//     .append("div")
//     .classed("svg-container", true)
//     .append("svg")
//     .attr("preserveAspectRatio", "xMinYMin meet")
//     .attr("width", "100%")
//     .attr("height", "100%")
//     .classed("svg-content-responsive", true)
//     .append("g")
//     .call(zoom)
//     .append("g");

// Draggable rectangle
var rect = svg.append('rect')
    .attr('width', 10000)
    .attr('height', 10000)
    .style('position', 'relative')
    .style('top', -5000)
    .style('left', -5000)
    .style('fill', 'none')
    .style("pointer-events", "all");

var container = svg.append("g");

// Per-type markers, as they don't inherit styles.
svg.append("defs").selectAll("marker")
    .data(["suit", "licensing", "resolved"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

/*
var path = container.append("g").selectAll("path")
    .data(force.links())
  .enter().append("path")
    .attr("class", function(d) { return "link " + d.type; })
    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

var circle = container.append("g").selectAll("circle")
    .data(force.nodes())
  .enter().append("circle")
    .attr("r", 6)
    .call(drag);

var text = container.append("g").selectAll("text")
    .data(force.nodes())
  .enter().append("text")
    .attr("x", 8)
    .attr("y", ".31em")
    .text(function(d) { return d.name; });

// Use elliptical arc path segments to doubly-encode directionality.
function tick() {
  path.attr("d", linkArc);
  circle.attr("transform", transform);
  text.attr("transform", transform);
}

function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

function zoomed() {
  container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
}

function dragged(d) {
  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed("dragging", false);
}

*/





var linkedByIndex = {};







//sort links by source, then target
links.sort(function(a,b) {
  if (a.source > b.source) {return 1;}
  else if (a.source < b.source) {return -1;}
  else {
    if (a.target > b.target) {return 1;}
    if (a.target < b.target) {return -1;}
    else {return 0;}
  }
});
//any links with duplicate source and target get an incremented 'linknum'
for (var i=0; i<links.length; i++) {
  if (i !== 0 &&
    links[i].source === links[i-1].source &&
    links[i].target === links[i-1].target) {
        links[i].linknum = links[i-1].linknum + 1;
    }
  else {links[i].linknum = 1;}
}


var link = svg.selectAll(".link")
  .data(links)
 .enter()
  .append("g")
  .attr("class", "link")
  .append("line")
  .attr("class", "link-line")
  .style("stroke-width", 1);

var linkText = svg.append("svg:g").selectAll("g.linklabelholder").data(force.links());

linkText.enter().append("g").attr("class", "linklabelholder")
   .append("text")
   .attr("class", "linklabel")
 .style("font-size", "13px")
   .attr("x", "50")
 .attr("y", "-20")
   .attr("text-anchor", "start")
   .style("fill","#000")
 .append("textPath")
   .attr("xlink:href",function(d,i) { return "#linkId_" + i;})
   .text(function(d) {
  return d.label;
 });


var path = svg.append("svg:g").selectAll("path")
  .data(force.links())
  .enter().append("svg:path")
  .attr("class", function(d) { return "link " + d.label; })
  .attr("id",function(d,i) { return "linkId_" + i; })
  .attr("marker-end", function(d) { return "url(#" + d.label + ")"; });

var node = svg.selectAll(".node")
  .data(nodes)
 .enter()
  .append("circle")
  .attr("class", "node")
  .attr("r", 20)
   .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
  .style("fill", function (d) { return color(d.type); })
  .on("mouseover", mouseover)
  .on("mouseout", mouseout)
  .call(drag);


var path_label = svg.append("svg:g").selectAll(".path_label")
  .data(force.links())
  .enter()
  .append("svg:text")
  .attr("class", "path_label")
  .append("svg:textPath")
  .attr("startOffset", "50%")
  .attr("text-anchor", "middle")
  .attr("xlink:href", function(d) { return "#" + d.source.index + "_" + d.target.index; })
  .style("fill", "#000")
  .style("font-family", "Arial")
  .text(function(d) { return d.label; });

var linkPath = link.append("svg:path")
  .attr("class", function(d) { return "link " + d.label; })
  .attr("marker-end", function(d) { return "url(#" + d.label + ")"; });

var textPath = link.append("svg:path")
  .attr("id", function(d) { return d.source.index + "_" + d.target.index; })
  .attr("class", "textpath");





svg.style("opacity", 1e-6)
  .transition()
  .duration(1000)
  .style("opacity", 1);

node.on("click", function(d) { d.fixed = true; });

node.on("dblclick", function(d) { d.fixed = false; });

node.append("title")
  .text(function (d) { return d.name; });

force.on("tick", function (e) {
  var k = 6 * e.alpha;

  i = 0;
  for (var key in nodes) {
    if (nodes.hasOwnProperty(key)) {
      nodes[key].y += i & 1 ? k : -k;
      nodes[key].x += i & 2 ? k : -k;
      i++;
    }
  }


  node.attr("cx", function(d) {
    return d.x = Math.max(r, Math.min(w - r, d.x));
  })
  .attr("cy", function(d) {
    return d.y = Math.max(r, Math.min(h - r, d.y));
  });
});

links.forEach(function(d) {
  linkedByIndex[d.source.index + "," + d.target.index] = 1;
  linkedByIndex[d.target.index + "," + d.source.index] = 1;
});


function neighboring(a, b) {
  return a.index === b.index || linkedByIndex[a.index + "," + b.index];
}

function mouseover(d) {
  d3.selectAll(".node").attr("r",30).style("stroke","black");
  d3.selectAll(".link").style("stroke","black").style("stroke-width",2);
  d3.selectAll(".link").transition().duration(500)
    .style("opacity", function(o) {
      return o.source === d || o.target === d ? 1 : .1;
  });

  d3.selectAll(".node").transition().duration(500)
    .style("opacity", function(o) {
      return neighboring(d, o) ? 1 : .1;
  });
}

function mouseout() {

	// var co = "path.link"+d.rtype;
  d3.selectAll(".node").attr("r",20).style("stroke","white");
  d3.selectAll(".link").attr("class", "link")
  .append("line").attr("class", "link-line").style("stroke-width",1);
  d3.selectAll(".link").transition().duration(500)
    .style("opacity", 1);
  d3.selectAll(".node").transition().duration(500)
    .style("opacity", 1);
}

function zoomed() {
	svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();

  d3.select(this).classed("dragging", true);
  force.start();
}

function dragged(d) {

  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);

}

function dragended(d) {

  d3.select(this).classed("dragging", false);
}
</script>
